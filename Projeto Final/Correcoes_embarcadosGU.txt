Aula 4:

 *Tabela de requisitos: está correta, mas recomendo colocar requisitos funcionais e não funcionais adicionais aos que eu apresentei. Recomendo também fazer uma tabela de especificações detalhando o sistema a ser construído. *Diagrama de casos de uso: não existe esse ator Controlador, o controle é feito pelo próprio sistema. O uso dos includes está incorreto. Utilizar extends quando necessário.Não apresenta as duas formas de como configurar a temperatura: via comunicação serial e via botões. *Cenários dos casos de uso: a ideia geral está correta, para cada caso de uso principal (que pode ter associações com outros casos de uso secundários através de includes e extends) vocês apresentaram um cenário. Esses cenários serão refeitos quando corrigirem os casos de uso, mas a idéia básica está correta * Diagrama de blocos: a apresentação desse diagrama como uma tabela não ficou boa, não é clara a ligação entre os blocos. Estão faltando alguns blocos (isso ficou mais claro agora que desenvolvemos códigos para mais dispositivos. Vale a pena representar os subblocos do microcontrolador. Também vale a pena detalhar as especificações dos componentes utilizados  (descrevendo o modelo, quando souber). *Diagrama de classes: "Menu" não é uma classe. Estão faltando várias classes. Adicionar as funções de inicialização dos objetos.   * Diagrama de blocos: estão faltando alguns blocos (isso ficou mais claro agora que desenvolvemos códigos para mais dispositivos). Vale a pena detalhar mais subsistemas do microcontrolador. Também vale a pena detalhar as especificações dos componentes utilizados  (descrevendo o modelo, quando souber). *Diagrama de classes: adicionar as funções de inicialização dos blocos."Menu" não é uma classe. Faltam várias classes.  O diagrama de classes deve representar fidedignamente o que foi implementado em C! Acho que vale a pena apresentar todas as multiplicidades  *Diagramas de sequência: muito simplificado. O diagrama de sequência deve ser coerente com o diagrama de classes. Ele deve mostrar como os métodos são chamados ao longo do tempo. Dessa forma, todos os objetos e chamadas de funções no diagrama de sequência deve existir no diagrama de classes, com os mesmos nomes. O seu não está assim (por exemplo, não existe o objeto Cooler), corrigir isso. Como regra geral, deve ser feito um diagrama de sequência para cada caso de uso (apesar de poder ser feito um diagrama de sequência que descreva todo o sistema). * Diagrama de máquina de estados: não está bom, extremamente simplificada. Estados podem ser descritos com subestados ou mesmo com outras máquinas de estado. Ele deve descrever os principais estados do sistema e os eventos que fazem com que o sistema mude de estado.

 


 Aula 8:

 Ao usar strncpy, é também interessante adicionar o caractere de fim de string após o último caractere da string de destino.  Além disso, lembrem que a primeira coluna é indicada por índice 0.
 ----- Não foi inserido o caracter de fim de string pois a intenção é imprimir no lcd diretamente os caracteres obtidos e somente separar em duas linhas se couber. 



Aula 10:

Atentem-se: * Na função selectDisp, lembrem que os pinos referentes aos displays são os 10, 11, 12 e 13. 

-- Ja está OK 
 

Aula 12:

* Não adicionou o projeto todo (adicionou somente os  arquivos fontes) * Entregaram no prazo. * Todos participaram *Implementaram tudo que foi pedido. * Cumpriram todas as regras do padrão de projeto * Código organizado, claro e bem comentado. *  Atentem-se: a linha "TPM1_SC   |= PWM_UP_COUNTING;" não consegue colocar um pino em LOW por se tratar de uma operação de OU. O mesmo é válido para a linha "TPM1_C0SC |= EDGE_ALIGNED_HIGH_TRUE;" * Observem que dentro da função main, a função boardInit() não foi chamada. * Observem também que apesar do período ser (MOD+1), esse valor não deve ser setado no registrador TPM1_CnV, pois o valor máximo de contagem aceito é definido pelo registrador TPM1_MOD * Além disso, é importante resetar o contador utilizando o registrador TPM1_CNT * Lembrem também que se trata de um sistema embarcado, então o looping da função main deve ser mantido pois não queremos que o programa seja finzalizado após as operações realizadas.

Aula 14:
* Não adicionou o projeto todo (adicionou somente os  arquivos fontes) * Entregaram no prazo. * Todos participaram * Implementaram tudo que foi pedido. * Cumpriram todas as regras de projeto. * Código claro, organizado e bem comentado. *  Interessante utilização dos periféricos em conjunto. * Observem que o registrador SIM_SCGC6 não é utlizado para un-gate do clock da porta E, e sim o SIM_SCGC5. * Atentem-se também que a linha SIM_SCGC6 |= SET_LTPMR0; não faz o un-gate da porta desejada. Para tal, o pino 24 deveria ser colocado em HIGH e não  o Pino 0 como foi feito. * Observem também que ao fazer "TPM0_SC |= TPM_MAX_VALUE_COUNT;", onde TPM_MAX_VALUE_COUNT=0xFFFF, os 16 primeiros pinos do registrado TPM0_SC foram colocados em HIGH, colocando o prescaler como 128, o modo de contagem em decrescente etc... Cuidado com as operações de bits realizadas. * Já a linha "SIM_SOPT4 |= TPM0CLKSEL_AS_CLKIN0;" não coloca o CLKIN0 como entrada. Para tal o pino 24 precisa ser colocado em LOW. Lembrem que fazer uma operação de OU com 0x00 retorna o próprio valor inicial. * Finalmente a função tachometer_readSensor não calcula a velocidade em RPM, observem que o valor do período está em microssegundos e deve portanto ser dividido por 1 milhão para que seja transformado em segundos. Observem também que ao dividir iCounted por uiPeriod e salvar em um int, o resultado será zero para qualquer valor de iCounted menor que 250000, fazendo com que a velocidade retornada seja 0.

Aulas 16 e 18:
* Não adicionou o projeto todo (adicionou somente os  arquivos fontes) * Entregaram no prazo. * Um único commit feito pelo Giácomo. * Implementaram tudo que foi pedido. * Cumpriram todas as regras do padrão de projeto. * Código organizado, mas poderia ser mais comentado. * Observem que a função setParam recebe como segundo parâmetro um unsigned char, mas a variável ucValue é um vetor de unsigned char (unsigned char *). * Não esqueçam do looping da main. Lembrem que se trata de um sistema embarcado, logo não queremos que ele seja finalizado após a inicialização da máquina de estados. * Apesar da máquina de estados ser o foco desse lab, seria interessante ter realizado a integração com funções dos periféricos (Duty Cycle) implementados em aulas anteriores.

Aula 20:
* Não adicionou o projeto inteiro. Somente os códigos source. * Entregaram no prazo * Todos participaram. * Implementaram tudo que foi pedido * A Regra 6 não foi atendida para a função setParam. * Código organizado e claro, mas poderia ser mais comentado. * Observem que a condição "while(0 != adc_isAdcDone())" faz com que o programa continue para adc_isAdcDone = 0, o que não é desejado, pois simboliza que o cálculo ainda não foi finalizado. * Observem também que a função extrai_digito escreve nos índices à direta da variável dígitos (índices 2 e 3), mas cTempText recebe os índices da esquerda de dígitos (índices 0 e 1). Por esse motivo, cTempText irá conter sempre "00.C" visto que os dois primeiros índices do vetor dígitos nunca são alterados e são inicializados como "00".
